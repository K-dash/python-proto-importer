use anyhow::{Context, Result};
use std::collections::BTreeSet;
use std::fs;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

pub mod apply;
pub mod fds;
pub mod rel_imports;

pub fn add_pyright_header(root: &Path) -> Result<usize> {
    use std::io::Write;
    let mut modified = 0usize;
    for entry in WalkDir::new(root).into_iter().filter_map(Result::ok) {
        let p = entry.path();
        if p.is_file() && p.extension().and_then(|s| s.to_str()) == Some("py") {
            let name = p.file_name().and_then(|s| s.to_str()).unwrap_or("");
            if !name.ends_with("_pb2.py") && !name.ends_with("_pb2_grpc.py") {
                continue;
            }
            let content = fs::read_to_string(p).with_context(|| format!("read {}", p.display()))?;
            let header = "# pyright: reportAttributeAccessIssue=false\n# This file is generated by grpcio-tools and may reference grpc.experimental which lacks stubs in types-grpcio.\n";
            if content.starts_with(header) {
                continue;
            }
            let mut f = fs::OpenOptions::new()
                .write(true)
                .truncate(true)
                .open(p)
                .with_context(|| format!("open {} for write", p.display()))?;
            f.write_all(header.as_bytes())?;
            f.write_all(content.as_bytes())?;
            modified += 1;
        }
    }
    Ok(modified)
}

pub fn create_packages(root: &Path) -> Result<usize> {
    let mut dirs: BTreeSet<PathBuf> = BTreeSet::new();
    for entry in WalkDir::new(root).into_iter().filter_map(Result::ok) {
        let path = entry.path();
        if path.is_dir() {
            dirs.insert(path.to_path_buf());
        }
    }

    let mut created = 0usize;
    for dir in dirs {
        let init_py = dir.join("__init__.py");
        if !init_py.exists() {
            fs::write(&init_py, b"")
                .with_context(|| format!("failed to write {}", init_py.display()))?;
            created += 1;
        }
    }
    Ok(created)
}
